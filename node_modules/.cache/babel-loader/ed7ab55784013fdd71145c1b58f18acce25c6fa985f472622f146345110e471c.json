{"ast":null,"code":"/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n *\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef {Element | Root} Result\n *   Result from a `h` (or `s`) call.\n *\n * @typedef {number | string} StyleValue\n *   Value for a CSS style field.\n * @typedef {Record<string, StyleValue>} Style\n *   Supported value of a `style` prop.\n * @typedef {boolean | number | string | null | undefined} PrimitiveValue\n *   Primitive property value.\n * @typedef {Array<number | string>} ArrayValue\n *   List of property values for space- or comma separated values (such as `className`).\n * @typedef {ArrayValue | PrimitiveValue} PropertyValue\n *   Primitive value or list value.\n * @typedef {{[property: string]: PropertyValue | Style}} Properties\n *   Acceptable value for element properties.\n *\n * @typedef {number | string | null | undefined} PrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n * @typedef {Array<ArrayChildNested | Nodes | PrimitiveChild>} ArrayChild\n *   List of children.\n * @typedef {Array<Nodes | PrimitiveChild>} ArrayChildNested\n *   List of children (deep).\n * @typedef {ArrayChild | Nodes | PrimitiveChild} Child\n *   Acceptable child value.\n */\n\nimport { parse as commas } from 'comma-separated-tokens';\nimport { parseSelector } from 'hast-util-parse-selector';\nimport { find, normalize } from 'property-information';\nimport { parse as spaces } from 'space-separated-tokens';\nconst own = {}.hasOwnProperty;\n\n/**\n * @param {Schema} schema\n *   Schema to use.\n * @param {string} defaultTagName\n *   Default tag name.\n * @param {Array<string> | undefined} [caseSensitive]\n *   Case-sensitive tag names (default: `undefined`).\n * @returns\n *   `h`.\n */\nexport function createH(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive && createAdjustMap(caseSensitive);\n\n  /**\n   * Hyperscript compatible DSL for creating virtual hast trees.\n   *\n   * @overload\n   * @param {null | undefined} [selector]\n   * @param {...Child} children\n   * @returns {Root}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {Properties} properties\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @param {string | null | undefined} [selector]\n   *   Selector.\n   * @param {Child | Properties | null | undefined} [properties]\n   *   Properties (or first child) (default: `undefined`).\n   * @param {...Child} children\n   *   Children.\n   * @returns {Result}\n   *   Result.\n   */\n  function h(selector, properties) {\n    let index = -1;\n    /** @type {Result} */\n    let node;\n    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      children[_key - 2] = arguments[_key];\n    }\n    if (selector === undefined || selector === null) {\n      node = {\n        type: 'root',\n        children: []\n      };\n      // Properties are not supported for roots.\n      const child = /** @type {Child} */properties;\n      children.unshift(child);\n    } else {\n      node = parseSelector(selector, defaultTagName);\n      // Normalize the name.\n      node.tagName = node.tagName.toLowerCase();\n      if (adjust && own.call(adjust, node.tagName)) {\n        node.tagName = adjust[node.tagName];\n      }\n\n      // Handle props.\n      if (isChild(properties)) {\n        children.unshift(properties);\n      } else {\n        /** @type {string} */\n        let key;\n        for (key in properties) {\n          if (own.call(properties, key)) {\n            addProperty(schema, node.properties, key, properties[key]);\n          }\n        }\n      }\n    }\n\n    // Handle children.\n    while (++index < children.length) {\n      addChild(node.children, children[index]);\n    }\n    if (node.type === 'element' && node.tagName === 'template') {\n      node.content = {\n        type: 'root',\n        children: node.children\n      };\n      node.children = [];\n    }\n    return node;\n  }\n  return h;\n}\n\n/**\n * Check if something is properties or a child.\n *\n * @param {Child | Properties} value\n *   Value to check.\n * @returns {value is Child}\n *   Whether `value` is definitely a child.\n */\nfunction isChild(value) {\n  // Never properties if not an object.\n  if (value === null || typeof value !== 'object' || Array.isArray(value)) {\n    return true;\n  }\n\n  // Never node without `type`; thatâ€™s the main discriminator.\n  if (typeof value.type !== 'string') return false;\n\n  // Slower check: never property value if object or array with\n  // non-number/strings.\n  const record = /** @type {Record<string, unknown>} */value;\n  const keys = Object.keys(value);\n  for (const key of keys) {\n    const value = record[key];\n    if (value && typeof value === 'object') {\n      if (!Array.isArray(value)) return true;\n      const list = /** @type {Array<unknown>} */value;\n      for (const item of list) {\n        if (typeof item !== 'number' && typeof item !== 'string') {\n          return true;\n        }\n      }\n    }\n  }\n\n  // Also see empty `children` as a node.\n  if ('children' in value && Array.isArray(value.children)) {\n    return true;\n  }\n\n  // Default to properties, someone can always pass an empty object,\n  // put `data: {}` in a node,\n  // or wrap it in an array.\n  return false;\n}\n\n/**\n * @param {Schema} schema\n *   Schema.\n * @param {Properties} properties\n *   Properties object.\n * @param {string} key\n *   Property name.\n * @param {PropertyValue | Style} value\n *   Property value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key);\n  let index = -1;\n  /** @type {PropertyValue} */\n  let result;\n\n  // Ignore nullish and NaN values.\n  if (value === undefined || value === null) return;\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return;\n    result = value;\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value;\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = spaces(value);\n    } else if (info.commaSeparated) {\n      result = commas(value);\n    } else if (info.commaOrSpaceSeparated) {\n      result = spaces(commas(value).join(' '));\n    } else {\n      result = parsePrimitive(info, info.property, value);\n    }\n  } else if (Array.isArray(value)) {\n    result = value.concat();\n  } else {\n    result = info.property === 'style' ? style(value) : String(value);\n  }\n  if (Array.isArray(result)) {\n    /** @type {Array<number | string>} */\n    const finalResult = [];\n    while (++index < result.length) {\n      // Assume no booleans in array.\n      const value = /** @type {number | string} */\n      parsePrimitive(info, info.property, result[index]);\n      finalResult[index] = value;\n    }\n    result = finalResult;\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // Assume no booleans in `className`.\n    const value = /** @type {number | string} */result;\n    result = properties.className.concat(value);\n  }\n  properties[info.property] = result;\n}\n\n/**\n * @param {Array<RootContent>} nodes\n *   Children.\n * @param {Child} value\n *   Child.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChild(nodes, value) {\n  let index = -1;\n  if (value === undefined || value === null) {\n    // Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({\n      type: 'text',\n      value: String(value)\n    });\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index]);\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children);\n    } else {\n      nodes.push(value);\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`');\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n *   Property information.\n * @param {string} name\n *   Property name.\n * @param {PrimitiveValue} value\n *   Property value.\n * @returns {PrimitiveValue}\n *   Property value.\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value);\n    }\n    if ((info.boolean || info.overloadedBoolean) && (value === '' || normalize(value) === normalize(name))) {\n      return true;\n    }\n  }\n  return value;\n}\n\n/**\n * Serialize a `style` object as a string.\n *\n * @param {Style} value\n *   Style object.\n * @returns {string}\n *   CSS string.\n */\nfunction style(value) {\n  /** @type {Array<string>} */\n  const result = [];\n  /** @type {string} */\n  let key;\n  for (key in value) {\n    if (own.call(value, key)) {\n      result.push([key, value[key]].join(': '));\n    }\n  }\n  return result.join('; ');\n}\n\n/**\n * Create a map to adjust casing.\n *\n * @param {Array<string>} values\n *   List of properly cased keys.\n * @returns {Record<string, string>}\n *   Map of lowercase keys to uppercase keys.\n */\nfunction createAdjustMap(values) {\n  /** @type {Record<string, string>} */\n  const result = {};\n  let index = -1;\n  while (++index < values.length) {\n    result[values[index].toLowerCase()] = values[index];\n  }\n  return result;\n}","map":{"version":3,"names":["parse","commas","parseSelector","find","normalize","spaces","own","hasOwnProperty","createH","schema","defaultTagName","caseSensitive","adjust","createAdjustMap","h","selector","properties","index","node","_len","arguments","length","children","Array","_key","undefined","type","child","unshift","tagName","toLowerCase","call","isChild","key","addProperty","addChild","content","value","isArray","record","keys","Object","list","item","info","result","Number","isNaN","spaceSeparated","commaSeparated","commaOrSpaceSeparated","join","parsePrimitive","property","concat","style","String","finalResult","className","nodes","push","Error","name","number","boolean","overloadedBoolean","values"],"sources":["C:/Users/lucas/Desktop/CONCORDIA/QUARCC/LAB/QuarccAI/node_modules/hastscript/lib/create-h.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n *\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef {Element | Root} Result\n *   Result from a `h` (or `s`) call.\n *\n * @typedef {number | string} StyleValue\n *   Value for a CSS style field.\n * @typedef {Record<string, StyleValue>} Style\n *   Supported value of a `style` prop.\n * @typedef {boolean | number | string | null | undefined} PrimitiveValue\n *   Primitive property value.\n * @typedef {Array<number | string>} ArrayValue\n *   List of property values for space- or comma separated values (such as `className`).\n * @typedef {ArrayValue | PrimitiveValue} PropertyValue\n *   Primitive value or list value.\n * @typedef {{[property: string]: PropertyValue | Style}} Properties\n *   Acceptable value for element properties.\n *\n * @typedef {number | string | null | undefined} PrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n * @typedef {Array<ArrayChildNested | Nodes | PrimitiveChild>} ArrayChild\n *   List of children.\n * @typedef {Array<Nodes | PrimitiveChild>} ArrayChildNested\n *   List of children (deep).\n * @typedef {ArrayChild | Nodes | PrimitiveChild} Child\n *   Acceptable child value.\n */\n\nimport {parse as commas} from 'comma-separated-tokens'\nimport {parseSelector} from 'hast-util-parse-selector'\nimport {find, normalize} from 'property-information'\nimport {parse as spaces} from 'space-separated-tokens'\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {Schema} schema\n *   Schema to use.\n * @param {string} defaultTagName\n *   Default tag name.\n * @param {Array<string> | undefined} [caseSensitive]\n *   Case-sensitive tag names (default: `undefined`).\n * @returns\n *   `h`.\n */\nexport function createH(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive && createAdjustMap(caseSensitive)\n\n  /**\n   * Hyperscript compatible DSL for creating virtual hast trees.\n   *\n   * @overload\n   * @param {null | undefined} [selector]\n   * @param {...Child} children\n   * @returns {Root}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {Properties} properties\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @param {string | null | undefined} [selector]\n   *   Selector.\n   * @param {Child | Properties | null | undefined} [properties]\n   *   Properties (or first child) (default: `undefined`).\n   * @param {...Child} children\n   *   Children.\n   * @returns {Result}\n   *   Result.\n   */\n  function h(selector, properties, ...children) {\n    let index = -1\n    /** @type {Result} */\n    let node\n\n    if (selector === undefined || selector === null) {\n      node = {type: 'root', children: []}\n      // Properties are not supported for roots.\n      const child = /** @type {Child} */ (properties)\n      children.unshift(child)\n    } else {\n      node = parseSelector(selector, defaultTagName)\n      // Normalize the name.\n      node.tagName = node.tagName.toLowerCase()\n      if (adjust && own.call(adjust, node.tagName)) {\n        node.tagName = adjust[node.tagName]\n      }\n\n      // Handle props.\n      if (isChild(properties)) {\n        children.unshift(properties)\n      } else {\n        /** @type {string} */\n        let key\n\n        for (key in properties) {\n          if (own.call(properties, key)) {\n            addProperty(schema, node.properties, key, properties[key])\n          }\n        }\n      }\n    }\n\n    // Handle children.\n    while (++index < children.length) {\n      addChild(node.children, children[index])\n    }\n\n    if (node.type === 'element' && node.tagName === 'template') {\n      node.content = {type: 'root', children: node.children}\n      node.children = []\n    }\n\n    return node\n  }\n\n  return h\n}\n\n/**\n * Check if something is properties or a child.\n *\n * @param {Child | Properties} value\n *   Value to check.\n * @returns {value is Child}\n *   Whether `value` is definitely a child.\n */\nfunction isChild(value) {\n  // Never properties if not an object.\n  if (value === null || typeof value !== 'object' || Array.isArray(value)) {\n    return true\n  }\n\n  // Never node without `type`; thatâ€™s the main discriminator.\n  if (typeof value.type !== 'string') return false\n\n  // Slower check: never property value if object or array with\n  // non-number/strings.\n  const record = /** @type {Record<string, unknown>} */ (value)\n  const keys = Object.keys(value)\n\n  for (const key of keys) {\n    const value = record[key]\n\n    if (value && typeof value === 'object') {\n      if (!Array.isArray(value)) return true\n\n      const list = /** @type {Array<unknown>} */ (value)\n\n      for (const item of list) {\n        if (typeof item !== 'number' && typeof item !== 'string') {\n          return true\n        }\n      }\n    }\n  }\n\n  // Also see empty `children` as a node.\n  if ('children' in value && Array.isArray(value.children)) {\n    return true\n  }\n\n  // Default to properties, someone can always pass an empty object,\n  // put `data: {}` in a node,\n  // or wrap it in an array.\n  return false\n}\n\n/**\n * @param {Schema} schema\n *   Schema.\n * @param {Properties} properties\n *   Properties object.\n * @param {string} key\n *   Property name.\n * @param {PropertyValue | Style} value\n *   Property value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key)\n  let index = -1\n  /** @type {PropertyValue} */\n  let result\n\n  // Ignore nullish and NaN values.\n  if (value === undefined || value === null) return\n\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return\n\n    result = value\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = spaces(value)\n    } else if (info.commaSeparated) {\n      result = commas(value)\n    } else if (info.commaOrSpaceSeparated) {\n      result = spaces(commas(value).join(' '))\n    } else {\n      result = parsePrimitive(info, info.property, value)\n    }\n  } else if (Array.isArray(value)) {\n    result = value.concat()\n  } else {\n    result = info.property === 'style' ? style(value) : String(value)\n  }\n\n  if (Array.isArray(result)) {\n    /** @type {Array<number | string>} */\n    const finalResult = []\n\n    while (++index < result.length) {\n      // Assume no booleans in array.\n      const value = /** @type {number | string} */ (\n        parsePrimitive(info, info.property, result[index])\n      )\n      finalResult[index] = value\n    }\n\n    result = finalResult\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // Assume no booleans in `className`.\n    const value = /** @type {number | string} */ (result)\n    result = properties.className.concat(value)\n  }\n\n  properties[info.property] = result\n}\n\n/**\n * @param {Array<RootContent>} nodes\n *   Children.\n * @param {Child} value\n *   Child.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChild(nodes, value) {\n  let index = -1\n\n  if (value === undefined || value === null) {\n    // Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index])\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n *   Property information.\n * @param {string} name\n *   Property name.\n * @param {PrimitiveValue} value\n *   Property value.\n * @returns {PrimitiveValue}\n *   Property value.\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value)\n    }\n\n    if (\n      (info.boolean || info.overloadedBoolean) &&\n      (value === '' || normalize(value) === normalize(name))\n    ) {\n      return true\n    }\n  }\n\n  return value\n}\n\n/**\n * Serialize a `style` object as a string.\n *\n * @param {Style} value\n *   Style object.\n * @returns {string}\n *   CSS string.\n */\nfunction style(value) {\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      result.push([key, value[key]].join(': '))\n    }\n  }\n\n  return result.join('; ')\n}\n\n/**\n * Create a map to adjust casing.\n *\n * @param {Array<string>} values\n *   List of properly cased keys.\n * @returns {Record<string, string>}\n *   Map of lowercase keys to uppercase keys.\n */\nfunction createAdjustMap(values) {\n  /** @type {Record<string, string>} */\n  const result = {}\n  let index = -1\n\n  while (++index < values.length) {\n    result[values[index].toLowerCase()] = values[index]\n  }\n\n  return result\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}